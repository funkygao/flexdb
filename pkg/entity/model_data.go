package entity

import (
	"fmt"
	"strconv"
	"strings"
	"time"

	"github.com/agile-app/flexdb/pkg/dto"
)

// PrepareCreateRow prepares data related info before creating the data.
func (m *Model) PrepareCreateRow(rd dto.RowData, pc PluginContext) (row *Row,
	clob *RowClob, indexes []Index, err error) {
	row = &Row{
		ModelID: m.ID,
		Memo:    rd.Memo(),
		CTime:   rd.CTime(),
		MTime:   rd.CTime(), // for create, mtime=ctime
		CUser:   rd.CUser(),
		Ver:     1,
		orgID:   m.OrgID,
	}

	indexes = make([]Index, 0, m.totalIndexesN())
	// 1st loop: parse input
	for k := range rd {
		v := rd.StrValueOf(k)
		if v == "" {
			// ignore null value
			continue
		}

		if columnNameReserved(k) {
			// skip builtin columns or illegal columns
			continue
		}

		c := m.SlotByName(k)
		if c == nil {
			err = fmt.Errorf("model:%s has invalid column: [%s]", m.Name, k)
			return
		}

		if c.Deprecated || c.Virtual() {
			continue
		}

		if _, yes := c.Plugin().(CellValueGenerator); yes {
			// value generated by plugin: not assigned from external source
			continue
		}

		// inject the plugin context
		c.PluginContext = pc

		if err = c.ValidateCellData(v); err != nil {
			return
		}

		if c.ClobWise() {
			// will persist in RowClob
			if clob == nil {
				clob = &RowClob{}
			}
			clob.SetField(c.clobSlot(), v)
			clob.orgID = m.OrgID
		} else {
			// will persist in Row
			row.SetField(c.Slot, v)
		}

		// the row is ready, then create corresponding index
		index, err := c.createIndexIfNec(v)
		if err != nil {
			return nil, nil, nil, err
		}
		// index be nil if c not indexed
		if index != nil {
			indexes = append(indexes, index)
		}
	}

	// 2nd loop: parse internal rules
	// enrich default value IfNec
	// generate cell value IfNec
	for _, c := range m.Slots {
		if c.Virtual() {
			continue
		}

		if !rd.HasField(c.Name) && c.Default != "" {
			row.SetField(c.Slot, c.Default)
		}

		if p, yes := c.Plugin().(CellValueGenerator); yes {
			if v, e := p.GenerateValue(); e == nil {
				row.SetField(c.Slot, v)
			} else {
				// internal error
				err = e
				return
			}
		}
	}

	return
}

// PrepareUpdateRow prepares all related entities for update a single row.
func (m *Model) PrepareUpdateRow(snapshot *Row, rd dto.RowData, pc PluginContext) (rowUpdates dto.RowData,
	row *Row, clob *RowClob, toAddindexes []Index, toUpdateIndexes []IndexUpdate, toDeleteIndexes []Index, err error) {
	row = snapshot
	row.orgID = m.OrgID
	row.MTime = time.Now()
	row.MUser = pc.PIN()

	// 直接使用row进行gorm.Updates的问题：如果该字段的值为空/false/0等，不会被update
	rowUpdates = make(map[string]interface{}, 3+len(rd)) // 3: muser,mtime,memo
	if snapshot.Memo != rd.Memo() {
		rowUpdates.SetMemo(rd.Memo())
		row.Memo = rd.Memo()
	}

	toAddindexes = make([]Index, 0)
	toDeleteIndexes = make([]Index, 0)
	toUpdateIndexes = make([]IndexUpdate, 0)
	for k := range rd {
		if columnNameReserved(k) {
			// skip builtin columns or illegal columns
			continue
		}

		slot := m.SlotByName(k)
		if slot.Deprecated || slot.ReadOnly || slot.Virtual() {
			continue
		}

		// inject the context
		slot.PluginContext = pc

		v := strings.TrimSpace(rd.StrValueOf(k)) // trim all cell values
		if v == "" && slot.Default != "" {
			v = slot.Default
		}
		if err = slot.ValidateCellData(v); err != nil {
			return
		}

		snapshotVal := snapshot.GetField(slot.Slot) // TODO what if clob
		if v == "" {
			if slot.Indexed && snapshotVal != "" {
				if idx, _ := slot.createIndexIfNec(v); idx != nil {
					idx.SetRowID(snapshot.ID)
					toDeleteIndexes = append(toDeleteIndexes, idx)
				}
			}
		} else {
			if snapshotVal == "" {
				if idx, _ := slot.createIndexIfNec(v); idx != nil {
					idx.SetRowID(snapshot.ID)
					toAddindexes = append(toAddindexes, idx)
				}
			} else if snapshotVal != v {
				// cell val change, secondary index change val
				if idx, _ := slot.createIndexIfNec(v); idx != nil {
					idx.SetRowID(snapshot.ID)
					toUpdateIndexes = append(toUpdateIndexes, IndexUpdate{Index: idx, OriginalVal: snapshotVal})
				}
			} else {
				// field data not changed
			}
		}

		if slot.ClobWise() {
			if snapshot.Clob == nil {
				if v != "" {
					// will insert into RowClob
					if clob == nil {
						clob = &RowClob{RowID: snapshot.ID}
					}
					clob.SetField(slot.clobSlot(), v)
					clob.orgID = m.OrgID
				}
			} else if snapshot.Clob.GetField(slot.clobSlot()) != v {
				// will update RowClob
				if clob == nil {
					clob = &RowClob{RowID: snapshot.ID}
				}
				clob.SetField(slot.clobSlot(), v)
				clob.orgID = m.OrgID
			}
		} else if snapshotVal != v {
			row.SetField(slot.Slot, v)
			rowUpdates["s"+strconv.Itoa(int(slot.Slot))] = v
		}
	}

	if len(rowUpdates) > 0 {
		rowUpdates.SetMTime(row.MTime)
		rowUpdates.SetMUser(row.MUser)
	}

	// TODO RowChangelog

	return
}

// PrepareDeleteRow prepares all related entities for delete a single row.
// Args:
// row: the db fetched row
func (m *Model) PrepareDeleteRow(row *Row, pc PluginContext) (indexes map[int16]Index,
	clob *RowClob, fakeDelete bool, err error) {
	if m.Feature.FakeDeleteEnabled() {
		fakeDelete = true
		row.Deleted = true
		row.MUser = pc.PIN()
		row.MTime = time.Now()
	}

	if row.HasClob() {
		clob = &RowClob{RowID: row.ID}
	}

	indexes = make(map[int16]Index, m.totalIndexesN())
	for _, slot := range m.Slots {
		if index, _ := slot.createIndexIfNec(row.GetField(slot.Slot)); index != nil {
			indexes[slot.Slot] = index
		}
	}

	return
}

// RenderRow interprets model meta info and fills rowdata with row.
// DB -> Row -> RenderRow -> RowData
func (m *Model) RenderRow(r Row, pc PluginContext, listView bool) dto.RowData {
	rd := make(dto.RowData, m.TotalColumnsN())
	for _, c := range m.Slots {
		if listView && !c.ListViewable() {
			continue
		}

		c.PluginContext = pc
		rd[c.Name] = r.evaluateCell(*c)

		if listView {
			if k, v := c.listViewExtraCell(r.GetField(c.Slot)); k != "" {
				// add an extra column based on this column
				rd[k] = v
			}
		}
	}

	// builtin column values
	rd.SetID(r.ID)
	rd.SetCTime(r.CTime)
	rd.SetMTime(r.MTime)
	rd.SetCUser(r.CUser)
	rd.SetMUser(r.MUser)
	rd.SetMemo(r.Memo)
	return rd
}
